# PP13-60-C1: Systemic Fix for Update/Delete Document Sync Issues

## Issue ID
PP13-60-C1

## Context
Please read 'Prompts/BasePrompt.md' first for general context.

## Problem Statement

### Root Cause Analysis
Investigation of PP13-60 revealed that ChromaDB Update and Delete operations successfully modify the local ChromaDB but fail to sync changes to Dolt due to multiple systemic issues:

1. **Primary Issue**: `ChromaUpdateDocumentsTool` and `ChromaDeleteDocumentsTool` don't set the `is_local_change = true` metadata flag that the detection system relies on
2. **Secondary Issue**: Content hash calculation is bypassed during update operations, preventing fallback detection mechanisms
3. **Tertiary Issue**: Delete operations make documents immediately invisible to detection systems, creating timing/visibility problems
4. **Design Gap**: No systematic approach for tracking deletions between ChromaDB and Dolt after documents are removed

### Evidence
- Test case showed `someid3` was not removed from Dolt despite successful ChromaDB deletion
- Test case showed `someid2` content was not updated in Dolt despite successful ChromaDB update  
- Detection log showed "0 deleted documents" detected even after delete operation
- Fallback mechanisms (`CompareContentHashesAsync`, `FindDeletedDocumentsAsync`) failed to catch changes

## Design Requirements

### 1. Update Operation Requirements
- **R1.1**: Update operations must set `is_local_change = true` flag
- **R1.2**: Update operations must recalculate and store `content_hash` in metadata
- **R1.3**: Update operations must be detectable by fallback mechanisms
- **R1.4**: Content hash changes must be properly tracked for sync validation

### 2. Delete Operation Requirements  
- **R2.1**: Delete operations must be trackable even after document removal from ChromaDB
- **R2.2**: Delete tracking must survive branch operations (checkout, merge, pull)
- **R2.3**: Delete tracking must handle complex scenarios (document never existed in target branch)
- **R2.4**: Delete tracking must be cleaned up after successful sync
- **R2.5**: Delete operations must not interfere with re-addition of documents with same ID

### 3. Deletion Tracking System Design

#### 3.1 External Deletion Tracking Storage
**⚠️ IMPORTANT**: The deletion tracking table must NOT be stored within the Dolt database itself to avoid version control interference. See detailed discussion in "Critical Design Consideration" section below.

Create a new SQLite database for deletion tracking (external to Dolt):

```sql
-- Stored in ./data/dev/deletion_tracking.db (NOT in Dolt)
CREATE TABLE local_deletions (
    id TEXT PRIMARY KEY,
    repo_path TEXT NOT NULL,           -- Scoped by repository path
    doc_id TEXT NOT NULL,
    collection_name TEXT NOT NULL,
    deleted_at DATETIME NOT NULL,
    deletion_source TEXT NOT NULL,     -- 'mcp_tool', 'sync', etc.
    original_content_hash TEXT,
    original_metadata TEXT,            -- JSON serialized
    branch_context TEXT,              -- branch where deletion occurred
    base_commit_hash TEXT,            -- commit hash when deletion occurred
    sync_status TEXT DEFAULT 'pending', -- 'pending', 'staged', 'committed'
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

#### 3.2 Deletion Lifecycle Management

**Phase 1: Deletion Request**
- Mark document for deletion in ChromaDB with temporary metadata
- Record deletion in `local_deletions` table
- Actually delete document from ChromaDB
- Update deletion record status to 'pending'

**Phase 2: Detection and Staging**
- `GetFlaggedLocalChangesAsync()` queries `local_deletions` for pending deletions
- Include deletion records in `LocalChanges.DeletedDocuments`
- Stage deletions to Dolt during sync operations
- Update status to 'staged'

**Phase 3: Commit and Cleanup**
- Commit staged changes including deletions
- Update status to 'committed'
- Clean up deletion records after successful commit

#### 3.3 Complex Scenario Handling

**Scenario: Delete + Checkout with Keep Changes**
1. User deletes document locally → Record in `local_deletions` with current branch context
2. User runs checkout with keep changes to target branch
3. System checks if document exists in target branch:
   - **Case A**: Document never existed in target → Safe to remove deletion record
   - **Case B**: Document exists in target → Keep deletion record, will become staged deletion
   - **Case C**: Document was also deleted in target → Merge deletion records or keep local
4. Handle conflicts appropriately with user feedback

**Scenario: Delete + Re-add Same ID**
1. User deletes document → Record in `local_deletions`
2. User adds new document with same ID → Check for existing deletion record
3. Options:
   - Replace deletion with modification if content differs from original
   - Remove deletion record if content matches original (no-op)
   - Create conflict resolution if timing is ambiguous

## Implementation Tasks

### Task 1: Enhance ChromaUpdateDocumentsTool
**Location**: `multidolt-mcp/Tools/ChromaUpdateDocumentsTool.cs`
**Priority**: HIGH

```csharp
// Before line 108 - Add content hash calculation and local change flagging
if (metadatas == null)
{
    metadatas = ids.Select(_ => new Dictionary<string, object>()).ToList();
}

for (int i = 0; i < metadatas.Count; i++)
{
    // Set local change flag
    metadatas[i]["is_local_change"] = true;
    
    // Calculate and store content hash if document content is being updated
    if (documents != null && i < documents.Count)
    {
        var contentHash = DocumentConverterUtilityV2.CalculateContentHash(documents[i]);
        metadatas[i]["content_hash"] = contentHash;
        
        // Log the update for audit trail
        _logger.LogInformation($"UpdateDocuments: Document {ids[i]} content hash updated to {contentHash}");
    }
    
    // Add update metadata
    metadatas[i]["last_updated"] = DateTime.UtcNow.ToString("O");
    metadatas[i]["update_source"] = "mcp_tool";
}
```

### Task 2: Implement Deletion Tracking System
**Location**: `multidolt-mcp/Services/DeletionTracker.cs` (new file)
**Priority**: HIGH

Create new service `IDeletionTracker` with methods:
- `TrackDeletionAsync(string docId, string collectionName, string originalContentHash, Dictionary<string, object> originalMetadata)`
- `GetPendingDeletionsAsync(string collectionName)` 
- `MarkDeletionStagedAsync(string docId, string collectionName)`
- `MarkDeletionCommittedAsync(string docId, string collectionName)`
- `CleanupCommittedDeletionsAsync()`
- `HandleBranchChangeAsync(string fromBranch, string toBranch, bool keepChanges)`

### Task 3: Enhance ChromaDeleteDocumentsTool
**Location**: `multidolt-mcp/Tools/ChromaDeleteDocumentsTool.cs`
**Priority**: HIGH

```csharp
// Replace existing deletion logic around line 95
// STEP 1: Get original document data before deletion
var originalDocs = await _chroma.GetDocumentsAsync(collectionName, ids);
var originalDocData = ExtractOriginalDocumentData(originalDocs);

// STEP 2: Track deletions in Dolt deletion tracking table
foreach (var docId in ids)
{
    if (originalDocData.ContainsKey(docId))
    {
        await _deletionTracker.TrackDeletionAsync(
            docId, 
            collectionName, 
            originalDocData[docId].ContentHash,
            originalDocData[docId].Metadata
        );
    }
}

// STEP 3: Mark documents with deletion flag temporarily (for immediate detection)
var deleteMetadata = ids.Select(_ => new Dictionary<string, object> 
{ 
    ["is_local_change"] = true,
    ["_pending_deletion"] = true,
    ["_deletion_timestamp"] = DateTime.UtcNow.ToString("O"),
    ["_deletion_source"] = "mcp_tool"
}).ToList();

// Update metadata to mark for deletion sync
await _chromaService.UpdateDocumentsAsync(collectionName, ids, metadatas: deleteMetadata);

// STEP 4: Actually delete the documents
var result = await _chromaService.DeleteDocumentsAsync(collectionName, ids);

// STEP 5: Update deletion tracking status
if (result)
{
    foreach (var docId in ids)
    {
        await _deletionTracker.MarkDeletionPendingAsync(docId, collectionName);
    }
}
```

### Task 4: Enhance Detection System
**Location**: `multidolt-mcp/Services/ChromaToDoltDetector.cs`
**Priority**: MEDIUM

Modify `GetFlaggedLocalChangesAsync()` to include deletion tracking:

```csharp
// Add after existing flagged changes detection
var pendingDeletions = await _deletionTracker.GetPendingDeletionsAsync(collectionName);
foreach (var deletion in pendingDeletions)
{
    deletedDocuments.Add(new DeletedDocumentV2
    {
        DocId = deletion.DocId,
        CollectionName = collectionName,
        OriginalContentHash = deletion.OriginalContentHash,
        ChunkIds = JsonSerializer.Serialize(new List<string>()) // Handle appropriately
    });
}
```

### Task 5: External Deletion Tracking Database Setup
**Location**: `multidolt-mcp/Services/DeletionTracking/` (new folder)  
**Priority**: HIGH

Create SQLite database initialization and schema management for external deletion tracking:
- Database creation and connection management
- Schema versioning and migration system for deletion tracking DB
- Cleanup routines for stale tracking records
- Backup and recovery mechanisms

### Task 6: Integration with Sync Operations
**Location**: `multidolt-mcp/Services/ChromaToDoltSyncer.cs`
**Priority**: HIGH

Update sync operations to:
- Stage deletion records to Dolt
- Commit deletion records  
- Clean up completed deletion tracking
- Handle conflicts between local deletions and remote changes

## Integration Test Specifications

### Test Suite 1: Basic Update/Delete Sync
**Test Class**: `UpdateDeleteSyncTests`

#### Test 1.1: Update Document Syncs to Dolt
```csharp
[Test]
public async Task UpdateDocument_ShouldSyncToDolt()
{
    // 1. Setup: Clone test repository with existing document
    // 2. Update document content via MCP tool
    // 3. Verify document marked with is_local_change=true
    // 4. Verify content hash updated in ChromaDB metadata
    // 5. Run detection - should find 1 modified document
    // 6. Commit changes
    // 7. Verify Dolt database reflects new content and hash
    // 8. Verify local change flag cleared after commit
}
```

#### Test 1.2: Delete Document Syncs to Dolt  
```csharp
[Test]
public async Task DeleteDocument_ShouldSyncToDolt()
{
    // 1. Setup: Clone test repository with existing document
    // 2. Delete document via MCP tool
    // 3. Verify document removed from ChromaDB
    // 4. Verify deletion recorded in local_deletions table
    // 5. Run detection - should find 1 deleted document
    // 6. Commit changes
    // 7. Verify document removed from Dolt database
    // 8. Verify deletion record cleaned up after commit
}
```

#### Test 1.3: Multiple Mixed Operations
```csharp
[Test] 
public async Task MixedOperations_ShouldAllSyncToDolt()
{
    // 1. Add 2 documents, update 1 existing, delete 1 existing
    // 2. Verify detection finds correct counts (2 new, 1 modified, 1 deleted)
    // 3. Commit and verify all changes reflected in Dolt
}
```

### Test Suite 2: Deletion Tracking Edge Cases
**Test Class**: `DeletionTrackingTests`

#### Test 2.1: Delete Then Checkout Keep Changes - Document Never Existed
```csharp
[Test]
public async Task DeleteThenCheckoutKeepChanges_DocumentNeverExisted_ShouldRemoveTracking()
{
    // 1. Setup: Branch A with document, Branch B without document
    // 2. On Branch A: Delete document locally
    // 3. Verify deletion tracking created
    // 4. Checkout Branch B with keep changes
    // 5. Verify deletion tracking removed (document never existed in Branch B)
    // 6. Verify no pending changes detected
}
```

#### Test 2.2: Delete Then Checkout Keep Changes - Document Exists in Target
```csharp
[Test]
public async Task DeleteThenCheckoutKeepChanges_DocumentExistsInTarget_ShouldKeepTracking()
{
    // 1. Setup: Both branches have document with different content
    // 2. On Branch A: Delete document locally  
    // 3. Verify deletion tracking created
    // 4. Checkout Branch B with keep changes
    // 5. Verify deletion tracking preserved
    // 6. Verify detection finds deletion as pending change
    // 7. Commit should delete document from Branch B
}
```

#### Test 2.3: Delete Then Re-add Same ID
```csharp
[Test]
public async Task DeleteThenReAddSameId_ShouldHandleCorrectly()
{
    // 1. Setup: Document with specific content
    // 2. Delete document locally
    // 3. Add new document with same ID but different content  
    // 4. Verify deletion tracking updated to modification
    // 5. Commit should show update, not delete+add
}
```

### Test Suite 3: Fallback Detection Validation
**Test Class**: `FallbackDetectionTests`

#### Test 3.1: Update Detection Without Local Change Flag
```csharp
[Test]
public async Task UpdateWithoutLocalFlag_FallbackDetectionShouldWork()
{
    // 1. Setup: Simulate old-style update that missed local change flag
    // 2. Update document content in ChromaDB but skip is_local_change flag
    // 3. Verify CompareContentHashesAsync detects the change
    // 4. Verify sync still works via fallback mechanism
}
```

#### Test 3.2: Delete Detection via Tracking Table
```csharp
[Test]
public async Task DeleteDetection_ViaDeletionTracking_ShouldWork()
{
    // 1. Setup: Document exists in both ChromaDB and Dolt
    // 2. Manually delete from ChromaDB and add to deletion tracking
    // 3. Verify GetPendingDeletionsAsync finds the deletion
    // 4. Verify sync processes deletion correctly
}
```

### Test Suite 4: Performance and Stress Tests
**Test Class**: `PerformanceTests`

#### Test 4.1: Large Scale Mixed Operations
```csharp
[Test]
public async Task LargeScale_MixedOperations_ShouldMaintainPerformance()
{
    // 1. Setup: 1000+ documents across multiple collections
    // 2. Perform 100 updates, 50 deletes, 25 adds simultaneously
    // 3. Verify all operations detected correctly within time limits
    // 4. Verify commit completes within acceptable time
    // 5. Verify cleanup of deletion tracking happens efficiently
}
```

### Test Suite 5: Concurrent Operations
**Test Class**: `ConcurrencyTests`

#### Test 5.1: Concurrent Update/Delete Operations
```csharp
[Test]
public async Task ConcurrentUpdateDelete_ShouldMaintainConsistency()
{
    // 1. Setup: Multiple threads performing operations simultaneously
    // 2. Verify detection system handles concurrent access correctly
    // 3. Verify deletion tracking maintains consistency
    // 4. Verify final sync state is correct and deterministic
}
```

## Critical Design Consideration: Deletion Tracking Storage

### Problem: Version Control Interference

**CRITICAL ISSUE**: The initial design proposed storing the `local_deletions` table within the Dolt database itself. This creates fundamental problems:

1. **Checkout Operations**: Switching branches/commits would overwrite deletion tracking with historical state
2. **Commit Operations**: Deletion tracking would be included in commits and synced to remotes  
3. **Pull Operations**: Remote changes could overwrite local deletion tracking
4. **Branch Operations**: Different branches would have different deletion tracking states
5. **Reset Operations**: Hard resets would lose deletion tracking data

### Revised Design: External Deletion Tracking Storage

#### Approach: Dedicated Local Database
Store deletion tracking in a separate SQLite database that exists alongside but outside of Dolt version control.

**Database Location**: `./data/dev/deletion_tracking.db`
**Schema**:
```sql
CREATE TABLE local_deletions (
    id TEXT PRIMARY KEY,
    repo_path TEXT NOT NULL,           -- Path to specific Dolt repository
    doc_id TEXT NOT NULL,
    collection_name TEXT NOT NULL,
    deleted_at DATETIME NOT NULL,
    deletion_source TEXT NOT NULL,
    original_content_hash TEXT,
    original_metadata TEXT,            -- JSON serialized
    branch_context TEXT,              -- Branch where deletion occurred
    base_commit_hash TEXT,            -- Commit hash when deletion occurred
    sync_status TEXT DEFAULT 'pending', -- 'pending', 'staged', 'committed'
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_repo_doc_collection ON local_deletions(repo_path, doc_id, collection_name);
CREATE INDEX idx_repo_sync_status ON local_deletions(repo_path, sync_status);
CREATE INDEX idx_repo_collection ON local_deletions(repo_path, collection_name);
```

#### Implementation Changes

**Modified DeletionTracker Interface**:
```csharp
public interface IDeletionTracker 
{
    Task InitializeAsync(string repoPath);
    Task TrackDeletionAsync(string repoPath, string docId, string collectionName, 
        string originalContentHash, Dictionary<string, object> originalMetadata, 
        string branchContext, string baseCommitHash);
    Task<List<DeletionRecord>> GetPendingDeletionsAsync(string repoPath, string collectionName);
    Task MarkDeletionStagedAsync(string repoPath, string docId, string collectionName);
    Task MarkDeletionCommittedAsync(string repoPath, string docId, string collectionName);
    Task CleanupCommittedDeletionsAsync(string repoPath);
    Task HandleBranchChangeAsync(string repoPath, string fromBranch, string toBranch, 
        string fromCommit, string toCommit, bool keepChanges);
    Task CleanupStaleTrackingAsync(string repoPath);
}
```

**Repository-Scoped Tracking**:
Since DMMS manages multiple repositories, deletion tracking must be scoped by repository path to prevent cross-contamination.

#### Branch Change Handling Logic

**Enhanced Branch Change Algorithm**:
```csharp
public async Task HandleBranchChangeAsync(string repoPath, string fromBranch, string toBranch, 
    string fromCommit, string toCommit, bool keepChanges)
{
    if (!keepChanges)
    {
        // Discard all pending deletions if not keeping changes
        await DiscardPendingDeletionsAsync(repoPath);
        return;
    }
    
    var pendingDeletions = await GetPendingDeletionsAsync(repoPath);
    
    foreach (var deletion in pendingDeletions)
    {
        // Check if document existed in target branch/commit
        var documentExistsInTarget = await CheckDocumentExistsInCommitAsync(
            repoPath, deletion.DocId, deletion.CollectionName, toCommit);
            
        if (!documentExistsInTarget)
        {
            // Document never existed in target branch - safe to remove tracking
            await RemoveDeletionTrackingAsync(repoPath, deletion.DocId, deletion.CollectionName);
            _logger.LogInformation($"Removed deletion tracking for {deletion.DocId} - document never existed in target branch {toBranch}");
        }
        else
        {
            // Document exists in target - keep deletion but update context
            await UpdateDeletionContextAsync(repoPath, deletion.DocId, deletion.CollectionName, 
                toBranch, toCommit);
            _logger.LogInformation($"Preserved deletion tracking for {deletion.DocId} - document exists in target branch {toBranch}");
        }
    }
}
```

#### Storage Location Strategy

**Primary Storage**: `./data/dev/deletion_tracking.db` (alongside ChromaDB storage)
**Backup Strategy**: Periodic backups to `./data/dev/deletion_tracking_backups/`
**Migration Strategy**: Automatic schema migrations on service startup

#### Integration with Existing Services

**Modified Task 2**: Update DeletionTracker implementation:
```csharp
public class SqliteDeletionTracker : IDeletionTracker
{
    private readonly ILogger<SqliteDeletionTracker> _logger;
    private readonly string _dbPath;
    private readonly SemaphoreSlim _semaphore = new(1, 1);
    
    public SqliteDeletionTracker(ILogger<SqliteDeletionTracker> logger, ServerConfiguration config)
    {
        _logger = logger;
        _dbPath = Path.Combine(config.DataPath, "dev", "deletion_tracking.db");
        Directory.CreateDirectory(Path.GetDirectoryName(_dbPath));
    }
    
    public async Task InitializeAsync(string repoPath)
    {
        await _semaphore.WaitAsync();
        try
        {
            // Create database and tables if not exists
            // Run migrations if needed
            // Clean up stale tracking records
        }
        finally
        {
            _semaphore.Release();
        }
    }
    
    // ... implement all interface methods using SQLite
}
```

**Service Registration**:
```csharp
// In Program.cs or ServiceConfiguration
services.AddSingleton<IDeletionTracker, SqliteDeletionTracker>();
```

#### Additional Test Cases for External Storage

**Test Suite 6: Deletion Tracking Storage Isolation**
```csharp
[Test]
public async Task DeletionTracking_NotAffectedByDoltCheckout()
{
    // 1. Setup: Create deletion tracking entries
    // 2. Perform Dolt checkout to different branch/commit
    // 3. Verify deletion tracking preserved independently
    // 4. Verify deletion tracking not visible in Dolt database
}

[Test]
public async Task DeletionTracking_MultiRepository_Isolation()
{
    // 1. Setup: Multiple Dolt repositories
    // 2. Create deletions in Repository A
    // 3. Verify deletions not visible in Repository B
    // 4. Verify repository-scoped cleanup works correctly
}

[Test]
public async Task DeletionTracking_SurvivesApplicationRestart()
{
    // 1. Create deletion tracking entries
    // 2. Simulate application restart (dispose and recreate services)
    // 3. Verify deletion tracking persists and loads correctly
}
```

#### Backup and Recovery Strategy

**Automated Backups**:
- Daily backup of deletion tracking database
- Retention of 30 days of backups
- Backup verification on startup

**Recovery Scenarios**:
- Corruption detection and automatic failover to backup
- Manual recovery procedures for edge cases
- Audit logging for all deletion tracking operations

#### Performance Considerations

**Optimization Strategies**:
- Connection pooling for SQLite operations
- Batch operations for large deletion sets
- Periodic cleanup of committed/stale records
- Indexing strategy for fast lookups by repository/collection

**Monitoring**:
- Track deletion tracking database size
- Monitor query performance
- Alert on excessive growth or corruption

## Success Criteria

### Functional Requirements
1. ✅ Update operations sync content changes to Dolt correctly
2. ✅ Delete operations sync deletions to Dolt correctly  
3. ✅ Detection system finds all changes reliably (primary + fallback)
4. ✅ Deletion tracking survives branch operations appropriately
5. ✅ Complex scenarios handle correctly without data loss
6. ✅ Performance impact minimal for normal operations

### Quality Requirements  
1. ✅ All integration tests pass consistently
2. ✅ No regression in existing functionality
3. ✅ Proper error handling and logging for edge cases
4. ✅ Cleanup mechanisms prevent resource leaks
5. ✅ Documentation updated for new deletion tracking system

## Notes
- This fix addresses both the immediate flagging issues AND the deeper detection system gaps
- The deletion tracking design handles complex git-like scenarios robustly
- Integration tests cover the full spectrum of edge cases identified
- Performance considerations built into the design from the start
- Backward compatibility maintained with existing detection mechanisms