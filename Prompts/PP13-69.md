- IssueID = PP13-69
- Please read 'Prompts/BasePrompt.md' first for general context
- This assignment addresses the critical architectural flaw where `chroma_sync_state` table is versioned in Dolt, causing irresolvable conflicts during branch checkout operations, especially in carry mode
- For context please read:
	- The test failure logs in 'Examples\260106_0930\TestBranchSwitchingValidation-639032881226077195.testlog' (specifically lines 3355-3394)
	- The previous SQLite deletion tracking work in PP13-60 (document deletions) and PP13-61 (collection deletions)
	- The current `chroma_sync_state` table structure in 'multidolt-mcp\Models\SyncDatabaseSchemaV2.sql'

## Problem Statement

The `chroma_sync_state` table currently exists in the Dolt versioned database, creating fundamental conflicts during branch operations. When switching branches with carry mode (`if_uncommitted=carry`), the system encounters an unresolvable paradox:

1. **Lines 3366-3368**: System attempts to `DROP TABLE IF EXISTS chroma_sync_state` to bypass conflicts
2. **Lines 3371-3373**: Checkout still fails with same error about `chroma_sync_state` having local changes
3. **Lines 3377-3379**: SyncManagerV2 fails with "Your local changes to the following tables would be overwritten by checkout"

This occurs because:
- The DROP operation itself becomes a tracked change in Dolt's staging area
- Dolt tracks table schema changes as part of version control
- The sync metadata conflicts with branch-specific state differences

## Architectural Solution

Move ALL `chroma_sync_state` data from Dolt (versioned) to SQLite (local-only), following the pattern established in PP13-60 (document deletions) and PP13-61 (collection deletions).

### Current Architecture (PROBLEMATIC)
```
├── Dolt (Versioned)
│   ├── documents table
│   ├── collections table
│   └── chroma_sync_state table ❌ (causes conflicts)
└── SQLite (Local)
    ├── local_deletions table
    └── local_collection_deletions table
```

### Proposed Architecture (CLEAN)
```
├── Dolt (Versioned)
│   ├── documents table
│   └── collections table
└── SQLite (Local)
    ├── local_deletions table
    ├── local_collection_deletions table
    └── sync_state table ✅ (no conflicts)
```

## Implementation Requirements

### 1. New SQLite Table Structure

Extend `SqliteDeletionTracker` (or create new `ISyncStateTracker`) with the following schema:

```sql
CREATE TABLE IF NOT EXISTS sync_state (
    id TEXT PRIMARY KEY,                    -- Unique ID for the record
    repo_path TEXT NOT NULL,                -- Repository path for isolation
    collection_name TEXT NOT NULL,           -- Collection name
    branch_context TEXT,                     -- Current branch name
    last_sync_commit TEXT,                   -- Last synced Dolt commit hash
    last_sync_at DATETIME,                   -- Timestamp of last sync
    document_count INTEGER DEFAULT 0,        -- Number of documents synced
    chunk_count INTEGER DEFAULT 0,           -- Number of chunks created
    embedding_model TEXT,                    -- Embedding model used
    sync_status TEXT DEFAULT 'pending',      -- Status: synced, pending, error, in_progress, local_changes
    local_changes_count INTEGER DEFAULT 0,   -- Count of uncommitted local changes
    error_message TEXT,                      -- Any error messages
    metadata TEXT,                           -- JSON metadata
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(repo_path, collection_name, branch_context)
);

CREATE INDEX idx_sync_state_repo ON sync_state(repo_path);
CREATE INDEX idx_sync_state_collection ON sync_state(repo_path, collection_name);
CREATE INDEX idx_sync_state_branch ON sync_state(repo_path, branch_context);
```

### 2. Interface Definition

Create or extend interfaces to support sync state tracking:

```csharp
public interface ISyncStateTracker
{
    // Initialize for repository
    Task InitializeAsync(string repoPath);
    
    // Sync state operations
    Task<SyncStateRecord?> GetSyncStateAsync(string repoPath, string collectionName, string? branchContext = null);
    Task UpdateSyncStateAsync(string repoPath, string collectionName, SyncStateRecord state);
    Task<List<SyncStateRecord>> GetAllSyncStatesAsync(string repoPath);
    Task ClearBranchSyncStatesAsync(string repoPath, string branchContext);
    
    // Reconstruction after checkout
    Task<bool> ReconstructSyncStateAsync(string repoPath, string newBranch);
}
```

### 3. Codebase Integration Points

The following components must be updated to use the new SQLite-based sync state:

#### Core Services
- **Services/SqliteDeletionTracker.cs**
  - Add sync_state table creation in `CreateDatabaseSchemaAsync()`
  - Implement ISyncStateTracker methods (or create separate class)

- **Services/SyncManagerV2.cs**
  - Replace all Dolt SQL operations for chroma_sync_state with SQLite calls
  - Key methods to update:
    - `UpdateSyncStateAsync()` - lines ~2500-2600
    - `GetSyncStateAsync()` - retrieval logic
    - `ProcessCheckoutAsync()` - remove sync state conflict workarounds (lines ~3364-3368)

- **Services/DeltaDetectorV2.cs**
  - Update `UpdateSyncStateAsync()` calls to use SQLite
  - Modify sync state queries

- **Services/ChromaToDoltSyncer.cs**
  - Remove any staging operations for chroma_sync_state table
  - Update to use SQLite for sync state tracking

#### Tools
- **Tools/DoltCheckoutTool.cs**
  - Remove sync state conflict handling logic
  - Add sync state reconstruction after successful checkout

- **Tools/DoltCommitTool.cs**
  - Ensure sync state is NEVER staged or committed
  - Update sync state in SQLite after successful commit

- **Tools/DoltCloneTool.cs**
  - Initialize sync state in SQLite after clone
  - Reconstruct sync state based on cloned content

#### Migration & Cleanup
- **Remove from Dolt Schema**
  - Update `Models/SyncDatabaseSchemaV2.sql` to remove chroma_sync_state table
  - Create migration script to drop existing chroma_sync_state tables

### 4. Test Updates Required

#### Tests That Must Be Updated
- **BranchSwitchingIntegrationTests.cs**
  - Remove expectations of sync state conflicts
  - Verify sync state reconstruction after checkout
  - Test carry mode without sync state interference

- **ChromaDoltSyncIntegrationTestsV2.cs**
  - Update to verify sync state in SQLite instead of Dolt
  - Remove any sync state conflict handling

- **MultiCollectionBranchSyncTests.cs**
  - Verify per-branch sync state isolation
  - Test sync state reconstruction after branch switches

- **PP13_68_* Integration Tests**
  - Update sync state verification to use SQLite
  - Remove sync state from content hash calculations

#### New Tests to Create
- **SyncStateTrackerTests.cs** (Unit Tests)
  - Test CRUD operations for sync state
  - Test branch-specific state isolation
  - Test reconstruction logic
  - Test cleanup operations

- **SyncStateMigrationTests.cs** (Integration Tests)
  - Test migration from Dolt to SQLite
  - Test backward compatibility handling
  - Test sync state reconstruction accuracy
  - Test multi-branch scenarios

### 5. Testing Strategy

#### Validation Scenarios
1. **Branch Switching with Carry Mode**
   - Create local changes in ChromaDB
   - Switch branches with `if_uncommitted=carry`
   - Verify NO sync state conflicts occur
   - Verify changes are properly carried

2. **Sync State Reconstruction**
   - Switch to different branch
   - Verify sync state is reconstructed based on actual content
   - Verify document counts and hashes match reality

3. **Multi-Branch Independence**
   - Create different sync states on multiple branches
   - Switch between branches
   - Verify each branch maintains independent sync state

4. **Clean Checkout**
   - Perform checkout without local changes
   - Verify sync state updates correctly
   - Verify no residual conflicts

#### Performance Validation
- Measure sync state reconstruction time
- Ensure no performance degradation
- Validate SQLite query performance

## Success Criteria

1. **Elimination of Checkout Conflicts**
   - `TestBranchSwitchingValidation` passes completely
   - No "chroma_sync_state" conflicts in any branch operation
   - Carry mode works without manual intervention

2. **Sync State Integrity**
   - Sync state accurately reflects actual ChromaDB-Dolt synchronization
   - Per-branch isolation is maintained
   - Reconstruction after checkout is accurate

3. **Backward Compatibility**
   - Existing repositories with Dolt-based sync state are migrated
   - No data loss during migration
   - Graceful handling of legacy sync state

4. **Test Coverage**
   - All updated tests pass
   - New tests validate all scenarios
   - No regression in existing functionality

## Implementation Phases

### Phase 1: Infrastructure (Priority: CRITICAL)
1. Create SQLite schema for sync_state table
2. Implement ISyncStateTracker interface
3. Add to SqliteDeletionTracker or create new tracker
4. Create unit tests for tracker

### Phase 2: Service Integration (Priority: HIGH)
1. Update SyncManagerV2 to use SQLite
2. Update DeltaDetectorV2 sync state calls
3. Remove sync state from staging operations
4. Update integration tests

### Phase 3: Tool Updates (Priority: HIGH)
1. Update DoltCheckoutTool to reconstruct state
2. Update DoltCommitTool to skip sync state
3. Update DoltCloneTool for initialization
4. Test branch operations

### Phase 4: Migration & Cleanup (Priority: MEDIUM)
1. Create migration scripts
2. Remove from Dolt schema
3. Update documentation
4. Performance testing

## Technical Considerations

### Thread Safety
- Use SemaphoreSlim for SQLite operations (following PP13-60 pattern)
- Ensure atomic updates during reconstruction

### Error Handling
- Graceful fallback if sync state unavailable
- Log warnings but don't fail operations
- Ability to rebuild from scratch

### Performance
- Cache frequently accessed sync states
- Batch updates where possible
- Optimize reconstruction queries

## Expected Outcomes

1. **Immediate Benefits**
   - Elimination of sync state checkout conflicts
   - Simplified branch switching logic
   - True branch independence for sync metadata

2. **Long-term Benefits**
   - Cleaner separation of concerns (user data vs metadata)
   - Easier debugging of sync issues
   - Foundation for future metadata extensions

3. **Risk Mitigation**
   - No risk of sync metadata corruption affecting user data
   - Ability to reset sync state without data loss
   - Simplified recovery from sync failures

This architectural change aligns with the principle established in PP13-60 and PP13-61: **operational metadata belongs in local SQLite, user data belongs in versioned Dolt**.