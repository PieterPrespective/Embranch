- IssueID = PP13-69-C6
- Please read 'Prompts/BasePrompt.md' first for general context
- Please read 'Prompts/PP13-69.md' and read from the PP13-69 'chroma-feat-design-planning-mcp' collection for the main architectural overhaul context
- Please read 'Prompts/PP13-69-C1.md', 'Prompts/PP13-69-C2.md', 'Prompts/PP13-69-C3.md', 'Prompts/PP13-69-C4.md', and 'Prompts/PP13-69-C5.md' for previous cleanup work; also check their respective 'chroma-feat-design-planning-mcp' collections

## Context: Test State Isolation Issues in PP13-69 Architecture

The PP13-69 architectural overhaul (SQLite-based sync state tracking) has exposed **fundamental test state isolation problems** in BranchSwitchingIntegrationTests.cs. While PP13-69-C5 addressed architectural compatibility issues, subsequent analysis revealed that **test failures are caused by cross-branch state contamination** rather than architectural incompatibility.

## Previous Work Completed:
- PP13-69 Phases 1-4: Complete architectural migration to SQLite-based sync state  
- PP13-69-C1: Simplified ProcessCheckoutAsync, eliminated defensive programming
- PP13-69-C2: Additional refactoring and cleanup
- PP13-69-C3: Test suite updates and validation
- PP13-69-C4: Fixed CollectionSyncIntegrationTests and ProductionInitializationIntegrationTests service registrations
- PP13-69-C5: Modernized BranchSwitchingIntegrationTests architectural compatibility (DI patterns, deprecated service removal)

## Critical Discovery: State Isolation Failure in PP13-69

### Root Cause Analysis

**Problem:** TestComplexDocumentLifecycleAcrossBranches expects 3 documents on feature-b branch but finds 4 documents.

**Deep Investigation Reveals:**
1. **PP13-69 checkout operations do NOT reset ChromaDB or SQLite state**
2. **Test assumptions about "clean branch state" are invalid** in PP13-69 architecture
3. **Cross-branch document contamination occurs** due to inadequate state isolation

### Evidence from Test Logs (Examples/260106_2259):

**Expected Document States:**
| Branch | Expected Documents | Actual Documents Found |
|--------|-------------------|------------------------|
| main | doc1, doc2, doc3 | doc1, doc2, doc3 ✓ |
| feature-a | doc1(modified), doc3, doc4 | doc1(modified), doc3, doc4 ✓ |
| feature-b | doc1, doc2(modified), doc5 | doc1, doc2(modified), doc4, doc5 ❌ |

**Critical Log Evidence:**
```
Document count mismatch: ChromaDB=3, Dolt=4
Collection alpha content differs - sync needed (document count: 4)
```

**Doc4 contamination:** doc4 from feature-a appears in feature-b Dolt state, proving cross-branch contamination.

### PP13-69 Reset Behavior Analysis

#### Current Reset Scope (INADEQUATE):
1. **DoltCheckoutTool reset_first mode:** No implementation - only proceeds with normal checkout
2. **SyncManagerV2.ResetHardAsync:** Only resets Dolt Git repository working directory
3. **No ChromaDB reset:** Collections persist across branch switches unless content differs
4. **No SQLite cleanup:** Sync state persists per branch (by design) but no cleanup methods called

#### Methods Available But Not Used:
- `ISyncStateTracker.ClearBranchSyncStatesAsync()`
- `ISyncStateTracker.DeleteSyncStateAsync()` 
- `IChromaDbService.DeleteCollectionAsync()`

**Conclusion:** PP13-69 reset operations are **intentionally limited to Dolt only** - they do not provide comprehensive state reset functionality.

## Assignment: Implement Comprehensive State Isolation for PP13-69 Branch Operations

### Required Actions:

#### **Phase 1: Enhanced Reset Functionality (HIGH PRIORITY)**

**1. Extend DoltCheckoutTool reset_first Implementation:**

Current inadequate implementation:
```csharp
// ❌ CURRENT: No actual reset
if (if_uncommitted == "reset_first")
{
    ToolLoggingUtility.LogToolInfo(_logger, toolName, "Reset first mode: discarding local changes before checkout");
    // This would require additional implementation for genuine user data reset
    // For now, proceed with normal checkout
}
```

**Required Implementation:**
```csharp
// ✅ REQUIRED: Comprehensive reset implementation
if (if_uncommitted == "reset_first")
{
    ToolLoggingUtility.LogToolInfo(_logger, toolName, "Reset first mode: discarding all local changes and resetting state");
    
    // Reset Dolt repository
    var resetResult = await _dolt.ResetHardAsync("HEAD");
    if (!resetResult.Success)
    {
        throw new InvalidOperationException($"Dolt reset failed: {resetResult.Error}");
    }
    
    // Reset ChromaDB state 
    await ResetChromaDBState();
    
    // Reset SQLite sync state for current branch
    var currentBranch = await _dolt.GetCurrentBranchAsync();
    await ResetSQLiteSyncState(currentBranch);
    
    ToolLoggingUtility.LogToolInfo(_logger, toolName, "Complete state reset completed");
}
```

**2. Implement ResetChromaDBState Method:**
```csharp
/// <summary>
/// Resets all ChromaDB collections to ensure clean state
/// </summary>
private async Task ResetChromaDBState()
{
    var existingCollections = await _chromaService.ListCollectionsAsync();
    foreach (var collection in existingCollections)
    {
        _logger.LogInformation("Deleting ChromaDB collection '{Collection}' for state reset", collection);
        await _chromaService.DeleteCollectionAsync(collection);
    }
}
```

**3. Implement ResetSQLiteSyncState Method:**
```csharp
/// <summary>
/// Resets SQLite sync state for specified branch to ensure clean tracking
/// </summary>
private async Task ResetSQLiteSyncState(string branchName)
{
    var repoPath = await _dolt.GetRepositoryPathAsync();
    
    _logger.LogInformation("Clearing SQLite sync state for branch '{Branch}'", branchName);
    await _syncStateTracker.ClearBranchSyncStatesAsync(repoPath, branchName);
}
```

#### **Phase 2: SyncManagerV2 Reset Integration (HIGH PRIORITY)**

**1. Add Comprehensive Reset to ProcessCheckoutAsync:**

Update SyncManagerV2.ProcessCheckoutAsync to support comprehensive reset when needed:
```csharp
// New parameter and logic
public async Task<SyncResultV2> ProcessCheckoutAsync(
    string targetBranch, 
    bool createNew = false, 
    bool preserveLocalChanges = false,
    bool resetAllState = false)  // NEW PARAMETER
{
    // ... existing logic ...
    
    if (resetAllState)
    {
        _logger.LogInformation("Performing comprehensive state reset before checkout to '{Branch}'", targetBranch);
        await PerformComprehensiveReset(targetBranch);
    }
    
    // ... rest of existing logic ...
}
```

**2. Implement PerformComprehensiveReset Method:**
```csharp
/// <summary>
/// Performs comprehensive reset of Dolt, ChromaDB, and SQLite state
/// </summary>
private async Task PerformComprehensiveReset(string targetBranch)
{
    // Reset Dolt to clean state
    var resetResult = await _dolt.ResetHardAsync("HEAD");
    if (!resetResult.Success)
    {
        throw new InvalidOperationException($"Dolt reset failed: {resetResult.Error}");
    }
    
    // Reset all ChromaDB collections
    var collections = await _chromaService.ListCollectionsAsync();
    foreach (var collection in collections)
    {
        _logger.LogInformation("Deleting ChromaDB collection '{Collection}' for comprehensive reset", collection);
        await _chromaService.DeleteCollectionAsync(collection);
    }
    
    // Reset SQLite sync state for target branch
    await _syncStateTracker.ClearBranchSyncStatesAsync(_doltConfig.RepositoryPath, targetBranch);
    
    _logger.LogInformation("Comprehensive state reset completed for branch '{Branch}'", targetBranch);
}
```

#### **Phase 3: Test State Isolation Framework (MEDIUM PRIORITY)**

**1. Create TestStateIsolationUtility:**
```csharp
/// <summary>
/// Utility for ensuring clean test state isolation in branch switching tests
/// </summary>
public static class TestStateIsolationUtility
{
    /// <summary>
    /// Ensures clean branch state before test operations
    /// </summary>
    public static async Task EnsureCleanBranchStateAsync(
        ISyncManagerV2 syncManager, 
        IChromaDbService chromaService,
        ISyncStateTracker syncStateTracker,
        string branchName,
        string repoPath)
    {
        // Force sync to ensure any pending changes are committed
        await syncManager.FullSyncAsync(forceSync: true);
        
        // Verify expected collections and document counts
        var collections = await chromaService.ListCollectionsAsync();
        foreach (var collection in collections)
        {
            var docCount = await chromaService.GetDocumentCountAsync(collection);
            _logger.LogInformation("Branch '{Branch}' collection '{Collection}': {Count} documents", 
                branchName, collection, docCount);
        }
        
        // Log sync state for debugging
        var syncStates = await syncStateTracker.GetAllSyncStatesAsync(repoPath);
        _logger.LogInformation("Branch '{Branch}' has {Count} sync state records", 
            branchName, syncStates.Count);
    }
    
    /// <summary>
    /// Forces complete state reset and re-sync from Dolt
    /// </summary>
    public static async Task ForceCleanStateResyncAsync(
        ISyncManagerV2 syncManager,
        IChromaDbService chromaService, 
        ISyncStateTracker syncStateTracker,
        string branchName,
        string repoPath)
    {
        // Delete all ChromaDB collections
        var collections = await chromaService.ListCollectionsAsync();
        foreach (var collection in collections)
        {
            await chromaService.DeleteCollectionAsync(collection);
        }
        
        // Clear sync state for this branch
        await syncStateTracker.ClearBranchSyncStatesAsync(repoPath, branchName);
        
        // Force full resync from Dolt
        await syncManager.FullSyncAsync(forceSync: true);
    }
}
```

**2. Update Test Methods for State Isolation:**

**TestComplexDocumentLifecycleAcrossBranches Fix:**
```csharp
// Before creating feature-b branch
await _doltCli.CheckoutAsync("main");
await _syncManager.ProcessCheckoutAsync("main", false);

// ✅ NEW: Ensure clean state before branch creation
await TestStateIsolationUtility.EnsureCleanBranchStateAsync(
    _syncManager, _chromaService, _syncStateTracker, "main", _tempDir);

// Verify main has exactly 3 documents before creating feature-b
var mainAlphaCount = await _chromaService.GetDocumentCountAsync("alpha");
Assert.That(mainAlphaCount, Is.EqualTo(3), 
    "Main branch must have exactly 3 documents before creating feature-b");

await _doltCli.CheckoutAsync("feature-b", createNew: true);

// ✅ NEW: Force clean state resync for new branch
await TestStateIsolationUtility.ForceCleanStateResyncAsync(
    _syncManager, _chromaService, _syncStateTracker, "feature-b", _tempDir);
```

#### **Phase 4: Validation and Debugging (LOW PRIORITY)**

**1. Enhanced State Validation:**
```csharp
/// <summary>
/// Validates branch state consistency and logs detailed information for debugging
/// </summary>
public static async Task ValidateBranchStateConsistencyAsync(
    ISyncManagerV2 syncManager,
    IChromaDbService chromaService,
    IDoltCli doltCli,
    string branchName)
{
    var currentBranch = await doltCli.GetCurrentBranchAsync();
    var commitHash = await doltCli.GetHeadCommitHashAsync();
    
    _logger.LogInformation("=== State Validation for Branch '{Branch}' (Current: '{Current}', Commit: '{Commit}') ===", 
        branchName, currentBranch, commitHash);
    
    // Validate ChromaDB state
    var chromaCollections = await chromaService.ListCollectionsAsync();
    foreach (var collection in chromaCollections)
    {
        var chromaCount = await chromaService.GetDocumentCountAsync(collection);
        _logger.LogInformation("ChromaDB '{Collection}': {Count} documents", collection, chromaCount);
    }
    
    // TODO: Add Dolt document count validation
    // TODO: Add sync state validation
}
```

### Test Priority for Implementation:

#### **IMMEDIATE (Phase 1-2):**
1. **DoltCheckoutTool reset_first implementation** - Fundamental reset functionality
2. **SyncManagerV2 comprehensive reset** - Core state management
3. **TestComplexDocumentLifecycleAcrossBranches fix** - Validate isolation works

#### **HIGH PRIORITY (Phase 3):**
4. **TestStateIsolationUtility** - Reusable test framework
5. **All BranchSwitchingIntegrationTests** - Apply isolation patterns

#### **MEDIUM PRIORITY (Phase 4):**
6. **Enhanced validation and debugging** - Better test diagnostics

### Success Criteria:

1. ✅ **DoltCheckoutTool reset_first mode performs comprehensive state reset** (Dolt + ChromaDB + SQLite)
2. ✅ **TestComplexDocumentLifecycleAcrossBranches passes consistently** with exactly 3 documents on feature-b
3. ✅ **No cross-branch document contamination** between test branches
4. ✅ **All BranchSwitchingIntegrationTests pass** with proper state isolation
5. ✅ **TestStateIsolationUtility provides reusable clean-state patterns** for other test suites
6. ✅ **Enhanced logging and validation** provides clear visibility into state transitions
7. ✅ **Performance maintained** - reset operations should be efficient (<2 seconds)

### Architecture Alignment:

This assignment **preserves PP13-69 architectural principles:**

1. **SQLite-based sync state tracking** - enhanced with controlled cleanup
2. **Branch-aware state management** - improved isolation without breaking design
3. **Efficient sync operations** - reset only when explicitly requested
4. **Separation of concerns** - test utilities don't modify core business logic

### Why This Matters:

**Reliable test state isolation** is critical for:

- **Deterministic test results** - no flaky failures due to state contamination
- **Branch operation validation** - ensure checkout tools work correctly
- **PP13-69 architecture confidence** - prove the new architecture handles complex scenarios
- **Developer productivity** - tests that accurately reflect real-world usage patterns

### Implementation Notes:

1. **Start with DoltCheckoutTool reset_first** - This provides the foundation for comprehensive reset
2. **Add comprehensive validation** - Ensure reset operations work correctly before using in tests  
3. **Apply to TestComplexDocumentLifecycleAcrossBranches first** - Validate the approach works
4. **Create reusable utilities** - Build framework other tests can use
5. **Monitor performance impact** - Ensure reset operations don't slow tests significantly

### Expected Outcome:

After completing this assignment, BranchSwitchingIntegrationTests should provide **reliable, deterministic validation** of branch switching operations with **proper state isolation** that prevents cross-branch contamination while maintaining the **performance and architectural integrity** of the PP13-69 system.