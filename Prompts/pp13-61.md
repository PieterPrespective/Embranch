- IssueID = PP13-61
- Please read 'Prompts/BasePrompt.md' first for general context
- The current DMMS system has a critical architectural gap - it only tracks document-level changes but ignores collection-level changes (creation, deletion, renaming/updates), leading to data inconsistency between ChromaDB and Dolt when collections are deleted or renamed
- For context please read the comprehensive investigation findings from PP13-60-C3 collection 'collection_deletion_investigation_report' which details the complete scope of the missing functionality
- Background Context:
	- Document deletion tracking was successfully implemented in PP13-60 and works correctly via SqliteDeletionTracker
	- Collection deletion currently only affects ChromaDB and never syncs to Dolt, creating orphaned collections and documents
	- Collection renaming/updates are not tracked at all, causing metadata drift between systems
	- The deletion tracker infrastructure exists and can be extended for collection-level operations
	- Dolt stores collections as first-class entities in the 'collections' table, making collection-level version control feasible

## Assignment Scope

### Primary Objectives
1. **Extend SqliteDeletionTracker** to handle collection-level operations (deletion, renaming/updates)
2. **Implement Collection Change Detection** to identify collection-level modifications in ChromaDB
3. **Integrate Collection Sync** into the existing commit/sync workflows
4. **Add Cascade Deletion Logic** to properly handle documents when collections are deleted
5. **Establish Production Initialization Patterns** to prevent PP13-60 style setup failures

### Secondary Objectives  
1. **Comprehensive Test Coverage** for collection lifecycle operations
2. **Production-Test Initialization Parity** to ensure consistent service setup
3. **Collection-Level Sync Integration** with existing SyncManagerV2 workflows
4. **Enhanced Change Detection** for both document and collection operations

## Technical Implementation Requirements

### Phase 1: Deletion Tracker Extension (Core Infrastructure)

#### 1.1 Database Schema Enhancement
- **Extend SqliteDeletionTracker** with new table for collection-level tracking:
```sql
CREATE TABLE IF NOT EXISTS local_collection_deletions (
    id TEXT PRIMARY KEY,
    repo_path TEXT NOT NULL,
    collection_name TEXT NOT NULL,
    operation_type TEXT NOT NULL,  -- 'deletion', 'rename', 'metadata_update'
    deleted_at DATETIME NOT NULL,
    deletion_source TEXT NOT NULL,
    original_metadata TEXT,        -- JSON metadata before deletion/change
    original_name TEXT,            -- For rename operations (old name)
    new_name TEXT,                 -- For rename operations (new name)
    branch_context TEXT,
    base_commit_hash TEXT,
    sync_status TEXT DEFAULT 'pending',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX IF NOT EXISTS idx_repo_collection_operation ON local_collection_deletions(repo_path, collection_name, operation_type);
CREATE INDEX IF NOT EXISTS idx_repo_collection_sync_status ON local_collection_deletions(repo_path, sync_status);
```

#### 1.2 IDeletionTracker Interface Extension
- **Add collection-level methods** to `IDeletionTracker` interface:
```csharp
// Collection-level deletion tracking
Task TrackCollectionDeletionAsync(string repoPath, string collectionName, 
    Dictionary<string, object> originalMetadata, string branchContext, string baseCommitHash);

// Collection rename/update tracking  
Task TrackCollectionUpdateAsync(string repoPath, string oldCollectionName, string newCollectionName,
    Dictionary<string, object> originalMetadata, Dictionary<string, object> newMetadata,
    string branchContext, string baseCommitHash);

// Collection deletion queries
Task<List<CollectionDeletionRecord>> GetPendingCollectionDeletionsAsync(string repoPath);
Task MarkCollectionDeletionCommittedAsync(string repoPath, string collectionName, string operationType);
Task CleanupCommittedCollectionDeletionsAsync(string repoPath);
```

#### 1.3 SqliteDeletionTracker Implementation
- **Implement collection tracking methods** in `SqliteDeletionTracker`
- **Add cascade document deletion logic** - when collection is deleted, automatically track all contained documents for deletion
- **Handle rename operations** - track both old and new collection names for proper sync
- **Extend initialization** to create collection deletion table schema

### Phase 2: Collection Change Detection

#### 2.1 Collection Change Detection Service
- **Create ICollectionChangeDetector** interface for detecting collection-level changes:
```csharp
public interface ICollectionChangeDetector
{
    Task<CollectionChanges> DetectCollectionChangesAsync();
    Task<bool> HasPendingCollectionChangesAsync();
}

public class CollectionChanges
{
    public List<string> DeletedCollections { get; set; } = new();
    public List<CollectionRename> RenamedCollections { get; set; } = new();
    public List<CollectionMetadataChange> UpdatedCollections { get; set; } = new();
}
```

#### 2.2 Collection Change Detection Logic
- **Compare ChromaDB vs Dolt collections** to identify:
  - Collections present in Dolt but missing in ChromaDB (deletions)
  - Collections with different metadata between systems (updates)
  - Collection name mismatches (potential renames - advanced)
- **Integrate with existing change detection** in ChromaToDoltDetector
- **Flag collection changes** for sync operations

### Phase 3: Tool Integration

#### 3.1 ChromaDeleteCollectionTool Enhancement
- **Integrate deletion tracking** into `ChromaDeleteCollectionTool`:
```csharp
// Before deletion
var originalMetadata = await GetCollectionMetadata(collectionName);

// Track deletion for sync
await _deletionTracker.TrackCollectionDeletionAsync(
    _repositoryPath, collectionName, originalMetadata, branchContext, baseCommitHash);

// Perform deletion
var result = await _chromaService.DeleteCollectionAsync(collectionName);
```

#### 3.2 Collection Update Tool (New)
- **Create ChromaModifyCollectionTool enhancement** to track collection updates/renames
- **Integrate tracking** for metadata changes and name changes
- **Ensure sync integration** for collection-level modifications

### Phase 4: Sync Integration

#### 4.1 SyncManagerV2 Enhancement
- **Add collection sync methods** to `ISyncManagerV2`:
```csharp
Task<CollectionSyncResult> SyncCollectionChangesAsync();
Task<CollectionSyncResult> StageCollectionChangesAsync();
```

#### 4.2 Commit Workflow Integration
- **Extend ProcessCommitAsync** to include collection changes:
  - Detect pending collection deletions/updates
  - Stage collection changes to Dolt
  - Update Dolt collections table appropriately
  - Handle cascade document deletions

#### 4.3 Cascade Deletion Implementation
- **When collection is deleted**:
  - Remove collection from Dolt collections table
  - Remove all documents belonging to collection from Dolt documents table
  - Track individual document deletions through existing mechanism
  - Ensure atomic operation (all-or-nothing)

### Phase 5: Production Initialization (Critical - Learned from PP13-60)

#### 5.1 Enhanced Program.cs Initialization
- **Extend existing deletion tracker initialization** to include collection schema:
```csharp
// Initialize both document and collection deletion tracking
await deletionTracker.InitializeAsync(doltConfiguration.RepositoryPath);

// Validate all required tables exist
await deletionTracker.ValidateSchemaAsync(doltConfiguration.RepositoryPath);
```

#### 5.2 Service Registration Validation
- **Add startup validation** to ensure all collection-related services are properly registered:
```csharp
// Validate collection change detector registration
var collectionDetector = host.Services.GetRequiredService<ICollectionChangeDetector>();
await collectionDetector.ValidateInitializationAsync();
```

#### 5.3 Fail-Fast Initialization Pattern
- **Apply lessons learned from PP13-60** where missing initialization caused silent failures
- **Ensure collection tracking services** initialize properly or fail application startup
- **Add comprehensive logging** for collection service initialization success/failure

## Testing Requirements (Critical - Prevent PP13-60 Issues)

### Test Infrastructure Setup (Mandatory Pattern)

#### Universal Test Initialization Pattern
**ALL integration tests MUST follow this pattern** to prevent PP13-60 style failures:
```csharp
private async Task InitializeTestEnvironmentAsync()
{
    // 1. Initialize deletion tracker (document + collection)
    await _deletionTracker.InitializeAsync(_tempDir);
    
    // 2. Initialize collection change detector  
    await _collectionChangeDetector.InitializeAsync(_tempDir);
    
    // 3. Validate all schemas exist
    await _deletionTracker.ValidateSchemaAsync(_tempDir);
    await _collectionChangeDetector.ValidateSchemaAsync(_tempDir);
    
    // 4. Create test collections in ChromaDB
    await _chromaService.CreateCollectionAsync(_testCollectionName);
    
    TestContext.WriteLine($"✓ Initialized test environment with complete service stack");
}
```

#### Dependency Injection Test Pattern
**ALL tests MUST register complete service stack**:
```csharp
// Create configuration instances (learned from PP13-60)
var serverConfig = new ServerConfiguration { ... };
var doltConfig = new DoltConfiguration { ... };

// Register configuration instances and options  
services.AddSingleton(serverConfig);
services.AddSingleton(Options.Create(serverConfig));
services.AddSingleton(doltConfig);
services.AddSingleton(Options.Create(doltConfig));

// Register all deletion/collection services
services.AddSingleton<IDeletionTracker, SqliteDeletionTracker>();
services.AddSingleton<ICollectionChangeDetector, CollectionChangeDetector>();

// Validate complete dependency chain
var serviceProvider = services.BuildServiceProvider();
var deletionTracker = serviceProvider.GetRequiredService<IDeletionTracker>();
var collectionDetector = serviceProvider.GetRequiredService<ICollectionChangeDetector>();
```

### Comprehensive Test Coverage

#### 5.1 Collection Deletion Tests
- **Integration test**: Delete collection in ChromaDB, commit, verify removal from Dolt
- **Cascade deletion test**: Verify all documents in deleted collection are removed from Dolt
- **Tracking validation test**: Verify deletion is properly tracked and marked committed
- **Rollback test**: Verify collection deletion can be undone before commit

#### 5.2 Collection Update/Rename Tests  
- **Metadata update test**: Change collection metadata, verify sync to Dolt
- **Collection rename test**: Rename collection, verify old name removed and new name created
- **Partial update test**: Update some metadata fields, verify only changed fields sync

#### 5.3 Mixed Operation Tests
- **Document + Collection changes**: Delete collection and documents in same commit
- **Multi-collection operations**: Delete/update multiple collections in single transaction
- **Conflict resolution**: Handle conflicts between collection and document operations

#### 5.4 End-to-End Workflow Tests
- **Complete lifecycle test**: Create → Update → Delete collection with full sync validation
- **Production simulation test**: Test collection operations in production-like environment
- **Service initialization test**: Validate all collection services initialize correctly in production

#### 5.5 Error Handling Tests
- **Initialization failure test**: Verify proper error handling when collection services fail to initialize
- **Partial sync failure test**: Handle failures during collection sync operations  
- **Cascade deletion failure test**: Handle failures during document cascade deletion

## Validation Criteria

### Functional Requirements
1. ✅ **Collection deletion** in ChromaDB must sync to Dolt (remove from collections table)
2. ✅ **Collection updates/renames** in ChromaDB must sync to Dolt (update collections table)
3. ✅ **Cascade deletion** must remove all documents when collection is deleted
4. ✅ **Mixed operations** (document + collection changes) must work in single commit
5. ✅ **Data consistency** between ChromaDB and Dolt at collection level

### Technical Requirements  
1. ✅ **Deletion tracker extension** handles collection operations without breaking document tracking
2. ✅ **Change detection** identifies collection-level modifications
3. ✅ **Sync integration** includes collection changes in commit workflows
4. ✅ **Production initialization** prevents PP13-60 style silent failures
5. ✅ **Test coverage** validates all collection lifecycle operations

### Production Readiness Requirements (Critical)
1. ✅ **Service initialization validation** - all collection services must initialize or fail-fast
2. ✅ **Schema validation** - all required database tables must exist after initialization  
3. ✅ **Dependency injection completeness** - all transitive dependencies properly registered
4. ✅ **Comprehensive logging** - clear success/failure messaging for debugging
5. ✅ **Error isolation** - collection operation failures don't break document operations

## Success Metrics

### Primary Success Criteria
- **Collection deletion workflow**: ChromaDB deletion → tracking → commit → Dolt removal → consistency ✅
- **Collection update workflow**: ChromaDB update → detection → commit → Dolt update → consistency ✅  
- **Cascade deletion**: Collection deletion properly removes all contained documents ✅
- **Production stability**: No silent failures like PP13-60, proper initialization validation ✅

### Quality Metrics
- **Test coverage**: >95% coverage for collection-level operations
- **Production initialization**: 100% reliable service setup following PP13-60 lessons
- **Data consistency**: Perfect ChromaDB-Dolt consistency for collection operations
- **Error handling**: Graceful degradation and clear error reporting

## Implementation Strategy

### Development Phases
1. **Phase 1** (Foundation): Extend deletion tracker and database schema
2. **Phase 2** (Detection): Implement collection change detection  
3. **Phase 3** (Integration): Tool updates and sync integration
4. **Phase 4** (Production): Enhanced initialization and validation
5. **Phase 5** (Testing): Comprehensive test coverage with proper initialization

### Risk Mitigation
- **Follow PP13-60 lessons**: Ensure production-test parity for service initialization
- **Incremental approach**: Build on existing document deletion infrastructure
- **Comprehensive validation**: Validate every initialization step with fail-fast design
- **Extensive testing**: Cover all collection lifecycle scenarios with proper setup patterns

This assignment addresses the fundamental architectural gap in collection-level version control while incorporating critical lessons learned from PP13-60 regarding proper service initialization and production-test parity.